/*
 * Filename: swc_clock.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Electronic Clock SWC
 * name: swc_Clock
 * shortname: Clock
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "swc_clock.h"



/* USER CODE START SWC_CLOCK_INCLUDE */

/* USER CODE END SWC_CLOCK_INCLUDE */

#include "tft.h"
#include "logging.h"
#include "sp_common.h"

/* USER CODE START SWC_CLOCK_USERDEFINITIONS */

/* USER CODE END SWC_CLOCK_USERDEFINITIONS */



/*
 * component: swc_Clock
 * cycletime: 50
 * description: Runnable handle button timer 
 * events: 
 * name: CLOCK_input_run
 * shortname: input
 * signalIN: 
 * signalOUT: so_event
 * task: tsk_io
 */
void CLOCK_input_run(RTE_event ev){
	
	/* USER CODE START CLOCK_input_run */
    
    
    SC_EVENT_data_t eventData = RTE_SC_EVENT_get(&SO_EVENT_signal);
    
    static uint16_t leftButtonElapsed =0;
    
    
    static uint16_t rightButtonElapsed =0;
    
    
    static uint16_t timeElapsed =0;
    static uint16_t shortEvent250msCount= 0;
    
    const uint16_t LONG_PRESS_THRESHOLD = 20; //(20 *50 =1000)
    const uint16_t ELAPSED_250MS = 5; // (5 *50 250)
    const uint16_t ONE_MIN_ELAPSED = 240; //(240 *50 =60000) <=> 240 250ms events
    
    // Event 1 Min / 250ms handling
    
    if (timeElapsed == ELAPSED_250MS){
        
        shortEvent250msCount++;
        ////LOG_I("Event count","%d",shortEvent250msCount);
        eventData.ev = EV_250MS;
        RC_t rc = RTE_SC_EVENT_set(&SO_EVENT_signal,eventData);
        timeElapsed =0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     }
    if (shortEvent250msCount == ONE_MIN_ELAPSED){
        LOG_D("Debug","1 Min Elapsed");
        eventData.ev = EV_1MIN;
        RC_t rc = RTE_SC_EVENT_set(&SO_EVENT_signal,eventData);
        shortEvent250msCount =0;
    }
    
    timeElapsed++;
    

    // Event Button 3 handling
    
    if(BUTTON_3_Read() == 1){
        leftButtonElapsed++;

    } else {
        
        if (leftButtonElapsed > 0){
            LOG_D("Debug","Key Left");
            leftButtonElapsed =0;
            eventData.ev = EV_KEYLEFT;
            
            RC_t result = RTE_SC_EVENT_set(&SO_EVENT_signal, eventData);
            if (result != RC_SUCCESS){
                // Todo error handling
            }
        }
        
        leftButtonElapsed =0;
    }
    // Handle key right event
    if(BUTTON_4_Read() == 1){
        rightButtonElapsed++;
        
    } else {
        // This code only works when button is released
        if (rightButtonElapsed > 0 && rightButtonElapsed <= LONG_PRESS_THRESHOLD ){
            rightButtonElapsed =0;
            //LOG_D("Debug","Key Right");
            eventData.ev = EV_KEYRIGHT;
            RC_t result = RTE_SC_EVENT_set(&SO_EVENT_signal, eventData);
        }
        else if (rightButtonElapsed >LONG_PRESS_THRESHOLD){
            rightButtonElapsed=0;
            //LOG_D("Debug","Key Right Long");
            eventData.ev = EV_KEYRIGHTLONG;
            RC_t result = RTE_SC_EVENT_set(&SO_EVENT_signal, eventData);
        }
       

        rightButtonElapsed =0;
    }
    
    /* USER CODE END CLOCK_input_run */
}

/*
 * component: swc_Clock
 * cycletime: 100
 * description: Runnable control state machine
 * events: ev_event_onData
 * name: CLOCK_control_run
 * shortname: control
 * signalIN: so_event
 * signalOUT: 
 * task: tsk_control
 */
void CLOCK_control_run(RTE_event ev){
	
	/* USER CODE START CLOCK_control_run */
    //Get the current clock data from the clock signal
    
    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&data);

    //Read the event from the EVENT signal

    SC_EVENT_data_t eventData = RTE_SC_EVENT_get(&SO_EVENT_signal);
    //Process the clock state machine
    
    STATE_processEvent(data.m_clockStateMachine, EVENT(eventData.ev));
    LOG_D("Processed event","%d",eventData.ev);
    
    //Get the latest clock data after running the state machine ( as the clock signal has a stateful implementation). 
    //Clock data was changed during state machine transition

    data = SC_CLOCK_INIT_DATA;

    RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&data);

    //Write the latest clock data back to clock signal
    RC_t result = RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);
    if(result != RC_SUCCESS){

        // Todo: error handling

    }
    /* USER CODE END CLOCK_control_run */
}

/*
 * component: swc_Clock
 * cycletime: 250
 * description: Runnable display on TFT
 * events: 
 * name: CLOCK_display_run
 * shortname: display
 * signalIN: so_clock
 * signalOUT: 
 * task: tsk_hmi
 */
void CLOCK_display_run(RTE_event ev){
	
	/* USER CODE START CLOCK_display_run */
    //Read the clock data

    SC_CLOCK_data_t clockData = SC_CLOCK_INIT_DATA;

    RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&clockData);

    

    //Transfer the clock data to clock display signal to run on lower priority hmi task

    RTE_SC_CLOCK_set(&SO_DISPLAY_signal,clockData);

    //Call the lower level TFT driver to display the clock data

    RTE_SC_CLOCK_pushPort(&SO_DISPLAY_signal);
    /* USER CODE END CLOCK_display_run */
}

/* USER CODE START SWC_CLOCK_FUNCTIONS */

/* USER CODE END SWC_CLOCK_FUNCTIONS */

