/*
 * Filename: sc_clock_type.c
 *
 * Author: Autogenerated by H-DA RTE Generator, (c) Prof. Fromm
 *
 * description: Storing clock data( hour + minute widget)
 * name: sc_clock
 * shortname: clock
 *
 */

#include "project.h"
#include "global.h"
#include "rte.h"
#include "rte_types.h"
#include "sc_clock_type.h"



/* USER CODE START SC_CLOCK_INCLUDE */
#include "sc_event_type.h"

#include "logging.h"

#include "sc_clock.h"

#include "sp_common.h"

#include "tft.h"



/* USER CODE END SC_CLOCK_INCLUDE */




/* USER CODE START SC_CLOCK_USERDEFINITIONS */

//Static functions prototype of the main clock container

static void CLOCK_updateDisplay();

static void CLOCK_increment1Min();

static void CLOCK_dispatch250MSToWdHour();

static void CLOCK_dispatchKeyLeftToWdHour();

static void CLOCK_dispatchKeyRightToWdHour();

static void CLOCK_disptachKeyRightLongToWdHour();



static void CLOCK_dispatch250MSToWdMin();

static void CLOCK_dispatchKeyLeftToWdMin();

static void CLOCK_dispatchKeyRightToWdMin();

static void CLOCK_disptachKeyRightLongToWdMin();



//Static functions of the widget

static void CLOCK_autoIncrementOneUnit();

static void CLOCK_autoIncrementTwoUnit();


static void CLOCK_setDisplayFonts();

static void CLOCK_setEditFonts();
//Clock Container State Machine Definition

/**  ===== IS_DISPLAYING ====   */

static const STATE_stateInnerTransitionTable_t CLOCK_IS_DISPLAYING_Transitions = {

/*    Event                   ToState                 		 Guard                       Action                       */

    { EVENT(EV_KEYLEFT),     STATE(IS_EDITING_HOUR),            0,                          CLOCK_dispatchKeyLeftToWdHour},

    { EVENT(EV_1MIN),         STATE(IS_DISPLAYING),              0,                          CLOCK_increment1Min         },

};



/**  ===== IS_EDITING_HOUR ====   */

static const STATE_stateInnerTransitionTable_t CLOCK_IS_EDITING_HOUR_Transitions = {

/*    Event                   ToState                 		 Guard                       Action                       */

    { EVENT(EV_KEYLEFT),     STATE(IS_EDITING_MIN),            0,                           CLOCK_dispatchKeyLeftToWdHour },

    { EVENT(EV_KEYRIGHT),    STATE(IS_EDITING_HOUR),           0,                           CLOCK_dispatchKeyRightToWdHour},

    { EVENT(EV_KEYRIGHTLONG),STATE(IS_EDITING_HOUR),           0,                       CLOCK_disptachKeyRightLongToWdHour},

    { EVENT(EV_250MS),       STATE(IS_EDITING_HOUR),           0,                       CLOCK_dispatch250MSToWdHour},

};



/**  ===== IS_EDITING_MIN====   */

static const STATE_stateInnerTransitionTable_t CLOCK_IS_EDITING_MIN_Transitions = {

/*    Event                   ToState                 		 Guard                       Action                       */

    { EVENT(EV_KEYLEFT),     STATE(IS_DISPLAYING),              0,                           CLOCK_dispatchKeyLeftToWdMin          },

    { EVENT(EV_KEYRIGHT),    STATE(IS_EDITING_MIN),             0,                           CLOCK_dispatchKeyRightToWdMin         },

    { EVENT(EV_KEYRIGHTLONG),    STATE(IS_EDITING_MIN),         0,                         CLOCK_disptachKeyRightLongToWdMin     },

    { EVENT(EV_250MS),    STATE(IS_EDITING_MIN),                0,                       CLOCK_dispatch250MSToWdMin},

};



static const STATE_stateOuterTransitionTable_t CLOCK_State_Transitions = {

/*    fromState                             Pointer to table                            Size of table [Elements]    */

    { STATE(IS_DISPLAYING),       &CLOCK_IS_DISPLAYING_Transitions,                sizeof(CLOCK_IS_DISPLAYING_Transitions)/sizeof(STATE_stateInnerTransition_t)    },

    { STATE(IS_EDITING_HOUR),       &CLOCK_IS_EDITING_HOUR_Transitions,                sizeof(CLOCK_IS_EDITING_HOUR_Transitions)/sizeof(STATE_stateInnerTransition_t)    },

    { STATE(IS_EDITING_MIN),       &CLOCK_IS_EDITING_MIN_Transitions,                sizeof(CLOCK_IS_EDITING_MIN_Transitions)/sizeof(STATE_stateInnerTransition_t)    },

};



static const STATE_stateAction_t CLOCK_State_StateActions[] = {

/*  fromState                           Entry                           Exit    */

  { STATE(IS_DISPLAYING),     CLOCK_updateDisplay,                       0   },
{ STATE(IS_DISPLAYING),     CLOCK_setDisplayFonts,                       0   },
{ STATE(IS_EDITING_HOUR),     CLOCK_setEditFonts,                       0   },
{ STATE(IS_EDITING_MIN),     CLOCK_setEditFonts,                       0   },
  

};





STATE_t CLOCK_StateMachine = {
    
    &CLOCK_State_Transitions,

    sizeof(CLOCK_State_Transitions)/sizeof(STATE_stateOuterTransition_t),

    &CLOCK_State_StateActions,

    sizeof(CLOCK_State_StateActions)/sizeof(STATE_stateAction_t),

    STATE(IS_DISPLAYING)

};





//Widget State Machine Definition

/**  ===== IS_EDITING ====   */

static const STATE_stateInnerTransitionTable_t CLOCK_IS_EDITING_Transitions = {

/*    Event                   ToState                 		 Guard                       Action                       */

    { EVENT(EV_KEYLEFT),     STATE(IS_EDITING),                 0,                          CLOCK_setEditFonts                      },

    { EVENT(EV_KEYRIGHT),    STATE(IS_EDITING),                 0,                          CLOCK_autoIncrementOneUnit },

    { EVENT(EV_KEYRIGHTLONG),STATE(IS_AUTO_INCREMENTING),       0,                          0                      },

};



/**  ===== IS_AUTO_INCREMENTING ====   */

static const STATE_stateInnerTransitionTable_t CLOCK_IS_AUTO_INCREMENTING_Transitions = {

/*    Event                   ToState                 		 Guard                       Action                       */

    { EVENT(EV_KEYLEFT),     STATE(IS_EDITING),                 0,                          0 },

    { EVENT(EV_KEYRIGHT),    STATE(IS_EDITING),                 0,                          0                      },

    { EVENT(EV_250MS),       STATE(IS_AUTO_INCREMENTING),       0,                          0                      },

};



static const STATE_stateOuterTransitionTable_t CLOCK_WidgetState_Transitions = {

/*    fromState                             Pointer to table                            Size of table [Elements]    */

    { STATE(IS_EDITING),                 &CLOCK_IS_EDITING_Transitions,      sizeof(CLOCK_IS_EDITING_Transitions)/sizeof(STATE_stateInnerTransition_t)    },

    { STATE(IS_AUTO_INCREMENTING),       &CLOCK_IS_AUTO_INCREMENTING_Transitions,    sizeof(CLOCK_IS_AUTO_INCREMENTING_Transitions)/sizeof(STATE_stateInnerTransition_t)  },

};



static const STATE_stateAction_t CLOCK_WidgetState_StateActions[] = {

/*  fromState                           Entry                           Exit    */

  { STATE(IS_EDITING),                      0,      0   },

  { STATE(IS_AUTO_INCREMENTING),     CLOCK_autoIncrementOneUnit,              0   },

};



STATE_t CLOCK_WidgetStateMachine = {

    &CLOCK_WidgetState_Transitions,

    sizeof(CLOCK_WidgetState_Transitions)/sizeof(STATE_stateOuterTransition_t),

    &CLOCK_WidgetState_StateActions,

    sizeof(CLOCK_WidgetState_StateActions)/sizeof(STATE_stateAction_t),


    STATE(IS_EDITING)

};




static void CLOCK_setDisplayFonts()
{

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    data.m_hourWidget.font_type.bg_color        =   BLACK;
    data.m_hourWidget.font_type.widget_color    =   WHITE;

    data.m_minWidget.font_type.bg_color      =   BLACK;
    data.m_minWidget.font_type.widget_color  =   WHITE;
    
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, data);
}

static void CLOCK_setEditFonts()
{

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);
    
    if(data.m_activeWidget == CLOCK_WIDGET_HOUR)
    {
        data.m_hourWidget.font_type.bg_color        =   WHITE;
        data.m_hourWidget.font_type.widget_color    =   BLACK;

        data.m_minWidget.font_type.bg_color      =   BLACK;
        data.m_minWidget.font_type.widget_color  =   WHITE;

    }
    else if(data.m_activeWidget == CLOCK_WIDGET_MIN){
        
        data.m_hourWidget.font_type.bg_color        =   BLACK;
        data.m_hourWidget.font_type.widget_color    =   WHITE;

        data.m_minWidget.font_type.bg_color      =   WHITE;
        data.m_minWidget.font_type.widget_color  =   BLACK;

    } else if(data.m_activeWidget == CLOCK_WIDGET_NONE){
        
        data.m_hourWidget.font_type.bg_color        =   BLACK;
        data.m_hourWidget.font_type.widget_color    =   WHITE;

        data.m_minWidget.font_type.bg_color      =   BLACK;
        data.m_minWidget.font_type.widget_color  =   WHITE;

    }
    
    RTE_SC_CLOCK_set(&SO_CLOCK_signal, data);
}



static void CLOCK_increment1Min(){
     
    LOG_D("Increment 1 min ","Container");
    //Read for the clock data

    SC_CLOCK_data_t clockData = SC_CLOCK_INIT_DATA;

    RC_t result = RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&clockData);


    if(result != RC_SUCCESS){

        // ToDo error handling

    }

    clockData.m_minWidget.m_value++;
    //Write the clock data back to the clock signal

    result = RTE_SC_CLOCK_set(&SO_CLOCK_signal,clockData);

    if(result != RC_SUCCESS){

        // Todo: Error Handling

    }



}

static void CLOCK_updateDisplay(){



    //Read for the clock data
    LOG_D("Update Display","Container");
    SC_CLOCK_data_t clockData = SC_CLOCK_INIT_DATA;

    RC_t rc = RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&clockData);


    if(rc != RC_SUCCESS){

        LOG_D("DEBUG", "CLOCK_updateDisplay(): Failed to read the clock signal\n");

    }

    else{


        //Set active widget to NONE

        clockData.m_activeWidget = CLOCK_WIDGET_NONE;




        //Check if 60 minutes have passed and update the hour accordingly

        if(clockData.m_minWidget.m_value >= 59){

            //Reset the minute of the clock data

            clockData.m_minWidget.m_value = 0;

            //Increment the hour of the clock data

            clockData.m_hourWidget.m_value++;

        }

        //Check if 24 hours have passed and reset the hour and minute of the clock accordingly

        if(clockData.m_hourWidget.m_value >= 24){

            //Reset hour and minute

            clockData.m_hourWidget.m_value = 0;

            clockData.m_minWidget.m_value = 0;

        }


        //Write the clock data back to the clock signal

        rc = RTE_SC_CLOCK_set(&SO_CLOCK_signal,clockData);

        if(rc != RC_SUCCESS){

            LOG_D("DEBUG", "CLOCK_updateDisplay(): Failed to write the clock signal\n");

        }

    }

}





/*****************************************************************************************
 *************** Event Dispatcher for Hour Widget  ****************
 *****************************************************************************************/



static void CLOCK_dispatch250MSToWdHour(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    

    //Set Widget Hour as active

    data.m_activeWidget = CLOCK_WIDGET_HOUR;

    

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    

    //Dispatch EV_250MS to widget hour

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_250MS));

    

}



static void CLOCK_dispatchKeyLeftToWdHour(){

    

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    

    //Set Widget Hour as active

    data.m_activeWidget = CLOCK_WIDGET_HOUR;

    

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    

    //Dispatch EV_KEYLEFT to widget hour

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYLEFT));

}



static void CLOCK_dispatchKeyRightToWdHour(){


    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);


    //Set Widget Hour as active

    data.m_activeWidget = CLOCK_WIDGET_HOUR;


    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);


    //Dispatch EV_KEYRIGHT to widget hour

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYRIGHT));

}



static void CLOCK_disptachKeyRightLongToWdHour(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    //Set Widget Hour as active

    data.m_activeWidget = CLOCK_WIDGET_HOUR;

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    //Dispatch EV_KEYRIGHTLONG to widget hour

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYRIGHTLONG));


}


/*****************************************************************************************
 *************** Event Dispatcher for Minute Widget  ****************
 *****************************************************************************************/

static void CLOCK_dispatch250MSToWdMin(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    //Set Widget Min as active

    data.m_activeWidget = CLOCK_WIDGET_MIN;

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    //Dispatch EV_250MS to widget min

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_250MS));

}


static void CLOCK_dispatchKeyLeftToWdMin(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    //Set Widget Min as active

    data.m_activeWidget = CLOCK_WIDGET_MIN;

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    //Dispatch EV_KEYLEFT to widget min

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYLEFT));

}



static void CLOCK_dispatchKeyRightToWdMin(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    //Set Widget Min as active

    data.m_activeWidget = CLOCK_WIDGET_MIN;

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);


    //Dispatch EV_KEYRIGHT to widget min

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYRIGHT));

}



static void CLOCK_disptachKeyRightLongToWdMin(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    data = RTE_SC_CLOCK_get(&SO_CLOCK_signal);

    //Set Widget Min as active

    data.m_activeWidget = CLOCK_WIDGET_MIN;

    //Update the active widget back to the clock signal

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

    //Dispatch EV_KEYRIGHTLONG to widget min

    STATE_processEvent(data.m_hourWidget.m_widgetStateMachine,EVENT(EV_KEYRIGHTLONG));

}

/*****************************************************************************************
 *************** Auto Incrementing for Widget  ****************
 *****************************************************************************************/
 

static void CLOCK_autoIncrementOneUnit(){
    LOG_D("Auto increment","Widget");
    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&data);

    //Check for the active widget

    switch (data.m_activeWidget){
        case CLOCK_WIDGET_NONE:
        //Do nothing
        break;
        case CLOCK_WIDGET_HOUR:

            data.m_hourWidget.m_value += 1;

            data.m_hourWidget.m_value %= 24;

            //Write back the clock data to the clock signal

        break;

        case CLOCK_WIDGET_MIN:


            data.m_minWidget.m_value += 1;

            data.m_minWidget.m_value %= 60;

            //Write back the clock data to the clock signal


        break;

    }

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

}


static void CLOCK_autoIncrementTwoUnit(){

    //Read for the clock data

    SC_CLOCK_data_t data = SC_CLOCK_INIT_DATA;

    RTE_SC_CLOCK_getThreadSafe(&SO_CLOCK_signal,&data);

    //Check for the active widget

    switch (data.m_activeWidget){
        case CLOCK_WIDGET_NONE:
        //Do nothing
        break;
        case CLOCK_WIDGET_HOUR:
        //Increment value of hour by 2 unit

            data.m_hourWidget.m_value += 2;

            data.m_hourWidget.m_value %= 24;

            //Write back the clock data to the clock signal

        break;

        case CLOCK_WIDGET_MIN:

            //Increment value of min by 2 unit

            data.m_minWidget.m_value += 2;

            data.m_minWidget.m_value %= 60;

            //Write back the clock data to the clock signal

        

        

        break;

    }

    RTE_SC_CLOCK_set(&SO_CLOCK_signal,data);

}





/* USER CODE END SC_CLOCK_USERDEFINITIONS */


/*****************************************************************************************
 *************** Port Wrapper Implementation for SC_CLOCK signal  ****************
 *****************************************************************************************/
 
 

/**
 * Default OUT driver API
 */
inline RC_t SC_CLOCK_driverOut(const SC_CLOCK_data_t  *const data)
{
	/* USER CODE START driverOutSC_CLOCK */
    
    
    
    static uint8_t toggle = 0;
    
    
    uint16_t local_hour_value = data->m_hourWidget.m_value;
    uint16_t local_minute_value = data->m_minWidget.m_value;
    
    uint16_t bg_color_hour = data->m_hourWidget.font_type.bg_color;
    uint16_t txt_color_hour = data->m_hourWidget.font_type.widget_color;
    
    uint16_t hour_size = data->m_hourWidget.font_type.size;
    uint16_t hour_x_pos = data->m_hourWidget.font_type.x_pos;
    uint16_t hour_y_pos = data->m_minWidget.font_type.y_pos;
    
    TFT_setCursor(hour_x_pos, hour_y_pos);
    TFT_setColors(txt_color_hour, bg_color_hour);
    TFT_setTextSize(hour_size);
    
    TFT_printf("%02d", local_hour_value);

    
    // Print : in the middle of the clock
    TFT_setColors(WHITE,BLACK);


    if(toggle   ==  0) {
        TFT_print(":");
        toggle  =   1;
    }
    else {
        TFT_print(" ");
        toggle  =    0;
        }
    
    
	uint16_t bg_color_min = data->m_minWidget.font_type.bg_color;
    uint16_t txt_color_min = data->m_minWidget.font_type.widget_color;
    
    uint16_t min_size = data->m_minWidget.font_type.size;
    uint16_t min_x_pos = data->m_minWidget.font_type.x_pos;
    uint16_t min_y_pos = data->m_minWidget.font_type.y_pos;
    
    TFT_setCursor(min_x_pos, min_y_pos);
    TFT_setColors(txt_color_min, bg_color_min);
    TFT_setTextSize(min_size);
    TFT_printf("%02d", local_minute_value);

	//Write scaled data to driver

	return RC_SUCCESS;
	/* USER CODE END driverOutSC_CLOCK */
}



